#!/usr/bin/env python3

# Copyright (c) 2021 Alethea Katherine Flowers.
# Published under the standard MIT License.
# Full text available at: https://opensource.org/licenses/MIT

import argparse
import os
import os.path
import platform
import pwd
import subprocess
import tempfile
import textwrap

from datetime import datetime, timezone


def username():
    return pwd.getpwuid(os.getuid())[0]


def extract_compiled_build_info(o_path):
    with tempfile.TemporaryDirectory() as dstdir:
        dst = os.path.join(dstdir, "output.txt")
        subprocess.run(
            [
                "arm-none-eabi-objcopy",
                "-O",
                "binary",
                "--only-section=.rodata.build_info",
                o_path,
                dst,
            ],
            check=True,
        )
        with open(dst, "r", encoding="utf-8") as fh:
            return fh.read().strip("\x00")


def generate_build_info_c(configuration):
    gcc_version = subprocess.run(
        ["arm-none-eabi-gcc", "-dumpversion"],
        capture_output=True,
        check=True,
        text=True,
    ).stdout.strip()

    try:
        release = subprocess.run(
            ["git", "describe", "--always", "--tags", "--abbrev=0"],
            capture_output=True,
            check=True,
            text=True,
        ).stdout.strip()
    except subprocess.CalledProcessError:
        release = "None"

    day, month, year = datetime.now(timezone.utc).strftime("%m.%d.%Y").split(".")

    try:
        revision = subprocess.run(
            ["git", "describe", "--always", "--dirty"],
            capture_output=True,
            check=True,
            text=True,
        ).stdout.strip()
    except subprocess.CalledProcessError:
        revision = "None"

    compiler = f"gcc {gcc_version}"

    date = datetime.now(timezone.utc).strftime("%m/%d/%Y %H:%M UTC")

    machine = f"{username()}@{platform.node()}"

    with open("./src/emon32.h", "r") as f:
        for ln in f:
            if "VERSION_FW" in ln:
                if "MAJ" in ln:
                    maj = ln.split()[-1].rstrip("u")
                elif "MIN" in ln:
                    min = ln.split()[-1].rstrip("u")
                elif "REV" in ln:
                    rev = ln.split()[-1].rstrip("u")
    version = f"v{maj}.{min}.{rev}"

    build_info_string = (
        f"{revision} ({configuration}) on {date} with {compiler} by {machine}"
    )

    return build_info_string, textwrap.dedent(
        f"""
    /* This file is generated by scripts/build_info.py - don't edit it directly!! */

    #include "emon32_build_info.h"

    static const char version[] = "{version}";
    static const char compiler[] = "{compiler}";
    static const char revision[] = "{revision}";
    static const char date[] = "{date}";
    static const char machine[] = "{machine}";
    static const char release[] = "{release}";
    static const char build_info[] = "{build_info_string}";

    struct Emon32BuildInfo emon32_build_info() {{
        return (struct Emon32BuildInfo){{
            .version = version,
            .revision = revision,
            .date = date,
            .compiler = compiler,
            .machine = machine,
            .release = release,
            .release_year = {year},
            .release_month = {month},
            .release_day = {day},
        }};
    }}

    const char* emon32_build_info_string() {{ return build_info; }}
    """
    )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", "--configuration", default="Default")
    parser.add_argument("output", type=argparse.FileType("w", encoding="utf-8"))

    args = parser.parse_args()

    info, output = generate_build_info_c(args.config)

    args.output.write(output)

    print(f"Build ID: {info}")


if __name__ == "__main__":
    main()
